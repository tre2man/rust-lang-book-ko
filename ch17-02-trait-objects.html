<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>트레잇 객체를 사용하여 다른 타입 간의 값 허용하기 - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="foreword.html">들어가기에 앞서</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">소개</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> 시작하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> 설치하기</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> 추리 게임 튜토리얼</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> 보편적인 프로그래밍 개념</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> 변수와 가변성</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> 데이터 타입들</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> 함수 동작 원리</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> 주석</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> 제어문</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> 소유권 이해하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> 소유권이 뭔가요?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> 참조자와 빌림</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> 슬라이스</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 연관된 데이터들을 구조체로 다루기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> 구조체를 정의하고 생성하기</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> 구조체를 이용한 예제 프로그램</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> 메소드 문법</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> 열거형과 패턴 매칭</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> 열거형 정의하기</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match 흐름 제어 연산자</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if let을 사용한 간결한 흐름 제어</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> 모듈</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod와 파일 시스템</a></li><li class="chapter-item expanded "><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> pub으로 가시성 제어하기</a></li><li class="chapter-item expanded "><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> use로 이름 가져오기</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> 일반적인 컬렉션</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> 벡터</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> 스트링</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> 해쉬맵</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> 에러 처리</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic!과 함께하는 복구 불가능한 에러</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result와 함께하는 복구 가능한 에러</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!이냐, panic!이 아니냐, 그것이 문제로다</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> 제네릭 타입, 트레잇, 그리고 라이프타임</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> 제네릭 데이터 타입</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> 트레잇: 공유 동작을 정의하기</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> 라이프타임을 이용한 참조자 유효화</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> 테스팅</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> 테스트 작성하기</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> 테스트 실행하기</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> 테스트 조직화</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> I/O 프로젝트: 커맨드 라인 프로그램 만들기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> 커맨드 라인 인자 허용하기</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> 파일 읽기</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> 모듈성과 에러처리의 향상을 위한 리팩토링</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> 테스트 주도 개발로 라이브러리의 기능 개발하기</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> 환경 변수들을 활용하기</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> 표준출력 대신 표준에러로 에러메시지 출력하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> 함수형 언어의 특성들: 반복자들과 클로저들</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> 클로저: 환경을 캡쳐할 수 있는 익명 함수</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> 반복자로 일련의 항목들 처리하기</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> I/O 프로젝트 개선하기</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> 성능 비교하기: 루프 vs. 반복자</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Cargo와 Crates.io 더 알아보기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> 릴리즈 프로필을 이용해 빌드 커스터마이징하기</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Crates.io에 크레이트 배포하기</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo 작업공간</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> cargo install을 이용해 Crates.io에서 바이너리 설치하기</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> 커스텀 명령어로 Cargo 확장하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> 스마트 포인터</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box&lt;T&gt;는 힙에 있는 데이터를 가리키고 알려진 크기를 갖습니다</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Deref 트레잇은 참조자를 통하여 데이터로의 접근을 허용합니다</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Drop 트레잇은 메모리 정리 코드를 실행시킵니다</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, 참조 카운팅 스마트 포인터</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt;와 내부 가변성 패턴</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> 순환 참조를 만드는 것과 메모리 누수는 안전한 것에 해당됩니다</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> 겁없는 동시성</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> 스레드</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> 메세지 패싱</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> 공유 상태</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> 확장 가능한 동시성: Sync와 Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> 러스트의 객체 지향 프로그래밍 기능들</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> 객체 지향 언어의 특성</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html" class="active"><strong aria-hidden="true">17.2.</strong> 트레잇 객체를 사용하여 다른 타입 간의 값 허용하기</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> 객체 지향 디자인 패턴 구현하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> 값의 구조와 매칭되는 패턴</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> 패턴이 사용될 수 있는 모든 곳</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> 반증 가능성: 패턴의 매칭이 실패할 수도 있는 경우</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> 패턴 문법의 모든 것</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> 고급 기능들</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> 안전하지 않은 러스트</a></li><li class="chapter-item expanded "><a href="ch19-02-advanced-lifetimes.html"><strong aria-hidden="true">19.2.</strong> 고급 라이프타임</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.3.</strong> 고급 트레잇</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.4.</strong> 고급 타입</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.5.</strong> 고급 함수와 클로저</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> 마지막 프로젝트: 멀티스레드 웹서버 만들기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> 싱글 스레드 웹서버</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> 싱글 스레드 서버를 멀티스레드 서버로 바꾸기</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 우아한 종료와 정리</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - 키워드</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - 연산자 및 기호</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - derive 가능한 트레잇</a></li><li class="chapter-item expanded "><a href="appendix-04-macros.html"><strong aria-hidden="true">21.4.</strong> D - 매크로</a></li><li class="chapter-item expanded "><a href="appendix-05-translation.html"><strong aria-hidden="true">21.5.</strong> E - 본 책의 번역본 목록</a></li><li class="chapter-item expanded "><a href="appendix-06-newest-features.html"><strong aria-hidden="true">21.6.</strong> F - 새로운 기능</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - 러스트가 만들어지는 과정과 “Nightly Rust”</a></li><li class="chapter-item expanded "><a href="appendix-08-glossary.html"><strong aria-hidden="true">21.8.</strong> H - 번역 용어 정리</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="트레잇-객체를-사용하여-다른-타입-간의-값-허용하기"><a class="header" href="#트레잇-객체를-사용하여-다른-타입-간의-값-허용하기">트레잇 객체를 사용하여 다른 타입 간의 값 허용하기</a></h2>
<p>8장에서는 벡터가 한 번에 하나의 타입만 보관할 수 있다는 제약사향이 있다고
언급했습니다. 우리가 만들었던 Listing 8-10의 작업내역에서는 정수, 부동소수점,
그리고 문자를 보관하기 위한 variant들을 가지고 있는 <code>SpreadsheetCell</code>
열거형을 정의했습니다. 이것은 우리가 각 칸마다 다른 타입의 데이터를 저장할 수
있으면서도 여전히 그 칸들의 한 묶음을 대표하는 벡터를 가질 수 있다는 것을
의미했습니다. 이는 우리의 교환가능한 아이템들이 코드를 컴파일할 때 알 수
있는 정해진 몇 개의 타입인 경우 완벽한 해결책입니다.</p>
<p>하지만, 가끔 우리는 우리의 라이브러리 사용자가 특정 상황에서 유효한 타입
묶음을 확장할 수 있도록 하길 원합니다. 우리가 원하는 바를 이룰 수 있는지를
보이기 위해, 우리는 아이템들의 리스트에 걸쳐 각각에 대해 <code>draw</code> 메소드를
호출하여 이를 화면에 그리는 그래픽 유저 인터페이스(GUI) 도구는 만들 것입니다 -
GUI 도구들에게 있어서는 흔한 방식이죠. 우리가 만들 라이브러리 크레이트는
<code>gui</code>라고 호명되고 GUI 라이브러리 구조를 포괄합니다. 이 크레이트는 사용자들이
사용할 수 있는 몇 가지 타입들, <code>Button</code>이나 <code>TextField</code> 들을 포함하게
될 것이구요. 추가로, <code>gui</code> 사용자들은 그들 고유의 타입을 만들어 그리고자
할 것입니다: 일례로, 어떤 프로그래머는 <code>Image</code>를 추가할지도 모르고 또다른
누군가는 <code>SelectBox</code>를 추가할지도 모르겠습니다.</p>
<p>우리는 이번 예제에서 총체적인 GUI 라이브러리를 구현하지 않겠지만 어떻게 이 조각들이
맞물려 함께 동작할 수 있는지 보여주고자 합니다. 라이브러리를 작성하는 시점에서는
다른 프로그래머들이 만들고자 하는 모든 타입들을 알 수 없죠. 하지만 우리가 알 수 있는
것은 <code>gui</code>가 다른 타입들의 다양한 값에 대해 계속해서 추적해야 하고, <code>draw</code> 메소드가
이 다양한 값들 각각에 호출되어야 한다는 겁니다. 우리가 <code>draw</code> 메소드를 호출했을 때
벌어지는 일에 대해서 정확히 알 필요는 없고, 그저 우리가 호출할 수 있는 해당 메소드를
그 값이 가지고 있음을 알면 됩니다.</p>
<p>상속이 있는 언어를 가지고 이 작업을 하기 위해서는 <code>draw</code> 라는 이름의 메소드를
갖고 있는 <code>Component</code> 라는 클래스를 정의할 수도 있습니다. 다른 클래스들, 이를테면
<code>Button</code>, <code>Image</code>, 그리고 <code>SelectBox</code> 같은 것들은 <code>Component</code>를 상속받고
따라서 <code>draw</code> 메소드를 물려받게 됩니다. 이들은 각각 <code>draw</code> 메소드를 오버라이딩하여
그들의 고유 동작을 정의할 수 있으나, 프레임워크는 모든 유형을 마치 <code>Component</code>인
것처럼 다룰 수 있고 <code>draw</code>를 호출할 수 있습니다. 하지만 러스트가 상속이 없는 관계로,
<code>gui</code> 라이브러리를 구축하는 다른 방법을 찾아 사용자들이 새로운 타입을 정의하고 확장할
수 있도록 할 필요가 있습니다.</p>
<h3 id="공통된-동작을-위한-트레잇-정의하기"><a class="header" href="#공통된-동작을-위한-트레잇-정의하기">공통된 동작을 위한 트레잇 정의하기</a></h3>
<p><code>gui</code>가 갖길 원하는 동작을 구현하기 위해, 우리는 <code>draw</code>라는 이름의 메소드
하나를 갖는 <code>Draw</code>라는 이름의 트레잇을 정의할 것입니다. 그러면 <em>트레잇 객체
(trait object)</em> 를 취하는 벡터를 정의할 수 있습니다. 트레잇 객체는 특정
트레잇을 구현한 타입의 인스턴스를 가리킵니다. 우리는 <code>&amp;</code> 참조자나 <code>Box&lt;T&gt;</code>
스마트 포인터 같은 포인터 종류로 명시함으로서 트레잇 객체를 만들고, 그런 다음
관련된 트레잇을 특정합니다. (우리가 트레잇 객체에 포인터를 사용해야 하는 이유는
19장의 “동적인 크기의 타입과 Sized” 절에서 다룰 겁니다.) 우리는 제네릭
타입이나 구체 타입 대신 트레잇 객체를 사용할 수 있습니다. 트레잇 객체를
사용하는 곳이 어디든, 러스트의 타입 시스템은 컴파일 타임에 해당 문맥 안에
사용된 값이 트레잇 객체의 트레잇을 구현할 것을 보장합니다. 결론적으로, 우리는
컴파일 타임에 모든 가능한 타입을 알 필요가 없습니다.</p>
<p>러스트에서는 구조체와 열거형을 다른 언어의 객체와 구분하기 위해
“객체”라고 부르는 것을 자제한다고 언급했었습니다. 구조체 또는
열거형에서는 구조체 필드의 데이터와 <code>impl</code> 블록의 동작이
분리되는 반면, 다른 언어에서는 데이터와 동작이 결합되어 객체로
명명됩니다. 그러나 트레잇 객체들은 데이터와 동작을 결합한다는
의미에서 다른 언어의 객체와 <em>비슷합니다</em>. 하지만 트레잇 객체는
트레잇 객체에 데이터를 추가 할 수 없다는 점에서 전통적인
객체들과 다릅니다. 트레잇 객체는 다른 언어들의 객체만큼 범용적으로
유용하지는 않습니다: 그들의 명확한 목적은 공통된 동작들에 걸친
추상화를 가능하도록 하는 것이죠.</p>
<p>Listing 17-3은 <code>draw</code>라는 이름의 메소드를 갖는 <code>Draw </code>라는 트레잇을 정의하는
방법을 보여줍니다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Draw {
    fn draw(&amp;self);
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 17-3: <code>Draw</code> 트레잇의 정의</span></p>
<p>이 문법은 10장에 있는 트레잇을 정의하는 방법에서 다뤘으니 익숙하실 겁니다.
다음에 새로운 문법이 등장합니다: Listing 17-4는 <code>components</code> 라는
벡터를 보유하고 있는 <code>Screen</code>이라는 구조체를 정의합니다. <code>Box&lt;Draw&gt;</code>
타입의 벡터인데, 이것이 트레잇 객체입니다; 이것은 <code>Draw</code> 트레잇을 구현한
<code>Box</code>에 담긴 임의의 타입에 대한 대역입니다.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen {
    pub components: Vec&lt;Box&lt;Draw&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 17-4: <code>Draw</code> 트레잇을
구현하는 트레잇 객체들의 벡터 항목 <code>components</code>를 소유한 구조체
<code>Screen</code></span></p>
<p><code>Screen</code> 구조체에서는 Listing 17-5와 같이 각 <code>components</code> 마다
<code>draw</code>메소드를 호출하는 <code>run</code> 메소드를 정의합니다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Screen {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 17-5: 각 컴포넌트에 대해 <code>draw</code> 메소드를
호출하는 <code>Screen</code>의 <code>run</code> 메소드</span></p>
<p>이것은 트레잇 바운드와 함께 제네릭 타입 파라미터를 사용하는 구조체를
정의하는 것과는 다르게 작동합니다. 제네릭 타입 파라미터는 한 번에
하나의 구체 타입으로만 대입될 수 있는 반면, 트레잇 객체를 사용하면
런타임에 여러 구체 타입을 트레잇 객체에 대해 채워넣을 수 있습니다.
예를 들면, Listing 17-6처럼 제네릭 타입과 트레잇 바운드를 사용하여
<code>Screen</code> 구조체를 정의할 수도 있을 겁니다.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen&lt;T: Draw&gt; {
    pub components: Vec&lt;T&gt;,
}

impl&lt;T&gt; Screen&lt;T&gt;
    where T: Draw {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 17-6: 제네릭과 트레잇 바운드를 사용한
<code>Screen</code> 구조체와 <code>run</code> 메소드의 대체 구현</span></p>
<p>이렇게하면 전부 <code>Button</code> 타입 혹은 전부 <code>TextField</code> 타입인 컴포넌트
리스트를 가지는 <code>Screen</code> 인스턴스로 제한됩니다. 동일 유형의 콜렉션만 사용한다면
제네릭과 특성 범위를 사용하는 것이 바람직한데, 왜냐하면 그 정의들은 구체 타입을
사용하기 위해 컴파일 타임에 단형성화 (monomorphize) 되기 때문입니다.</p>
<p>반면에 트레잇 객체를 사용하는 메소드를 이용할때는 하나의 <code>Screen</code> 인스턴스가
<code>Box&lt;Button&gt;</code> 혹은  <code>Box&lt;TextField&gt;</code>도 담을 수 있는 <code>Vec&lt;T&gt;</code>를 보유할
수 있습니다. 이것이 어떻게 작동하는지 살펴보고 런타임 성능에 미치는 영향에 대해
설명하겠습니다.</p>
<h3 id="트레잇-구현하기"><a class="header" href="#트레잇-구현하기">트레잇 구현하기</a></h3>
<p>이제 우리는 <code>Draw</code> 트레잇을 구현하는 몇가지 타입을 추가하려고 합니다. 우리는
<code>Button</code> 타입을 제공할 것입니다. 다시금 말하지만, 실제 GUI 라이브러리를
구현하는 것은 이 책의 범위를 벗어나므로, 우리는 <code>draw</code>에는 별다른 구현을 하지
않을 겁니다. 구현하려는 것을 상상해보자면, <code>Button</code> 구조체는 Listing 17-7에서
보시는 바와 같이 <code>width</code>, <code>height</code> 그리고 <code>label</code> 항목들을 가지게 될 것입니다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&amp;self) {
        // code to actually draw a button
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 17-7: <code>Draw</code> 트레잇을 구현하는
<code>Button</code> 구조체</span></p>
<p><code>Button</code>의 <code>width</code>, <code>height</code> 및 <code>label</code> 필드는 다른 컴포넌트와는
차이가 있는데, <code>TextField</code> 타입을 예로 들면, 이 필드들에 추가로
<code>placeholder</code> 필드를 소유할 겁니다. 우리가 화면에 그리고자 하는 각각의
타입은 <code>Draw</code> 트레잇을 구현할테지만 해당 타입을 그리는 방법을 정의하기
위하여 <code>draw</code> 메소드 내에 서로 다른 코드를 사용하게 될 것이며, <code>Button</code>이
그러한 경우죠 (이 챕터의 범주를 벗어나기 때문에 실질적인 GUI 코드는 없지만요).
예를 들어, <code>Button</code> 타입은 추가적인 <code>impl</code> 블록에 사용자가 버튼을 클릭했을
때 어떤 일이 벌어질지와 관련된 메소드들을 포함할 수 있습니다. 이런 종류의
메소드는 <code>TextField</code>와 같은 타입에는 적용할 수 없죠.</p>
<p>우리의 라이브러리를 사용하는 누군가가 <code>width</code>, <code>height</code> 및 <code>options</code>
필드가 있는 <code>SelectBox</code> 구조체를 구현하기로 했다면, Listing 17-8과 같이
<code>SelectBox</code> 타입에도 <code>Draw</code> 트레잇을 구현합니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate gui;
use gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn draw(&amp;self) {
        // code to actually draw a select box
    }
}</code></pre>
<p><span class="caption">Listing 17-8: <code>gui</code>를 사용하고 <code>Draw</code> 트레잇을
<code>SelectBox</code> 구조체에 구현한 또 다른 크레이트</span></p>
<p>우리 라이브러리의 사용자는 이제 <code>Screen</code> 인스턴스를 만들기 위해 <code>main</code> 함수를
구현할 수 있습니다. <code>Screen</code> 인스턴스에는 <code>SelectBox</code>와 <code>Button</code>가
트레잇 객체가 되도록 하기 위해 <code>Box&lt;T&gt;</code> 안에 넣음으로서 이들을 추가할 수 있습니다.
그러면 <code>Screen</code> 인스턴스 상의 <code>run</code> 메소드를 호출할 수 있는데, 이는 각 컴포넌트들에
대해 <code>draw</code>를 호출할 것입니다. Listing 17-9는 이러한 구현을 보여줍니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use gui::{Screen, Button};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from(&quot;Yes&quot;),
                    String::from(&quot;Maybe&quot;),
                    String::from(&quot;No&quot;)
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from(&quot;OK&quot;),
            }),
        ],
    };

    screen.run();
}</code></pre>
<p><span class="caption">Listing 17-9: 트레잇 객체를 사용하여 동일한 트레잇을
구현하는 서로 다른 타입들의 값 저장하기</span></p>
<p>우리가 라이브러리를 작성할 때는, 누군가 <code>SelectBox</code> 타입을 추가할 수도
있다는 것을 알 수 없었지만, 우리의 <code>Screen</code> 구현체는 새로운 타입에 대해서도
동작하고 이를 그려낼수 있는데, 그 이유는 <code>SelectBox</code>가 <code>Draw</code> 타입을 구현했기
때문이고, 이는 <code>draw</code> 메소드가 구현되어 있음을 의미합니다.</p>
<p>이러한 개념 —값의 구체적인 타입이 아닌 값이 응답하는 메시지 만을 고려하는 개념—
은 동적 타입 언어들의 <em>오리 타이핑 (duck typing)</em> 이란 개념과 유사합니다:
만약 오리처럼 뒤뚱거리고 오리처럼 꽥꽥거리면, 그것은 오리임에 틀림없습니다!
Listing 17-5에 나오는 <code>Screen</code>에 구현된 <code>run</code>을 보면, <code>run</code>은 각
컴포넌트가 어떤 구체적 타입인지 알 필요가 없습니다. 이 함수는 컴포넌트가
<code>Button</code>의 인스턴스인지 혹은 <code>SelectBox</code>의 인스턴스인지 검사하지 않고
그저 각 컴포넌트의 <code>draw</code> 메소드를 호출할 뿐입니다. <code>components</code> 벡터에
담기는 값의 타입을 <code>Box&lt;Draw&gt;</code>로 특정함으로서 우리는 <code>draw</code> 메소드를
호출할 수 있는 값을 요구하는 <code>Screen</code>을 정의했습니다.</p>
<p>오리 타이핑을 사용하는 코드와 유사한 코드를 작성하기 위해서 트레잇 객체와
러스트의 타입 시스템을 사용하는 것의 장점은 어떤 값이 특정한 메소드를 구현했는지를
검사해야 하거나 혹은 값이 메소드를 구현하지 않았는데 우리가 그걸 어쨌든 호출한다면
생길 수 있는 에러에 대한 걱정을 전혀 할 필요가 없다는 겁니다. 러스트는 트레잇
객체가 요구하는 트레잇을 해당 값이 구현하지 않았다면 컴파일하지 않을 겁니다.</p>
<p>예를 들어, Listing 17-10은 <code>String</code>을 컴포넌트로 사용하여 <code>Screen</code>을
생성하는 시도를 하면 어떤 일이 벌어지는지 보여줍니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate gui;
use gui::Screen;

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(String::from(&quot;Hi&quot;)),
        ],
    };

    screen.run();
}</code></pre>
<p><span class="caption">Listing 17-10: 트레잇 객체의 트레잇을 구현하지 않은
타입의 사용 시도하기</span></p>
<p>우리는 아래와 같은 에러를 보게 될 것이며 이유는 <code>String</code> 이 <code>Draw</code> 트레잇을 구현하지 않기 때문입니다:</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::string::String: gui::Draw` is not satisfied
  --&gt; src/main.rs:7:13
   |
 7 |             Box::new(String::from(&quot;Hi&quot;)),
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait gui::Draw is not
   implemented for `std::string::String`
   |
   = note: required for the cast to the object type `gui::Draw`
</code></pre>
<p>이 에러는 우리가 넘길 뜻이 없었던 무언가를 <code>Screen</code>에게 넘기는 중이고 이를
다른 타입으로 교체해야 하거나, 혹은 우리가 <code>String</code>에 대해 <code>Draw</code>를 구현하여
<code>Screen</code>이 이것에 대해 <code>draw</code>를 호출할 수 있도록 해야한다는 것을 알려줍니다.</p>
<h3 id="트레잇-객체는-동적-디스패치를-수행합니다"><a class="header" href="#트레잇-객체는-동적-디스패치를-수행합니다">트레잇 객체는 동적 디스패치를 수행합니다</a></h3>
<p>10장의 “제네릭을 사용한 코드의 성능“ 절에서 우리가 제네릭에 트레잇
바운드를 사용했을 때 컴파일러에 의해 이뤄지는 단형성화 프로세스의 실행에
대한 논의를 상기해보세요: 컴파일러는 우리가 제네릭 타입 파라미터를 사용한
각각의 구체 타입을 위한 함수와 메소드의 제네릭 없는 구현체를 생성합니다.
단형성화로부터 야기된 코드는 <em>정적 디스패치 (static dispatch)</em> 를
수행하는데, 이는 여러분이 호출하고자 하는 메소드가 어떤 것인지 컴파일러가
컴파일 시점에 알고 있는 것입니다. 이는 <em>동적 디스패치 (dynamic
dispatch)</em> 와 반대되는 개념으로, 동적 디스패치는 컴파일러가 여러분이
호출하는 메소드를 컴파일 시에 알 수 없을 경우 수행됩니다. 동적 디스패치의
경우, 컴파일러는 런타임에 어떤 메소드가 호출되는지 알아내는 코드를 생성합니다.</p>
<p>우리가 트레잇 객체를 사용할 때, 러스트는 동적 디스패치를 이용해야 합니다. 컴파일러는
트레잇 객체를 사용중인 코드와 함께 사용될 수도 있는 모든 타입을 알지 못하기 때문에,
어떤 타입에 구현된 어떤 메소드를 호출할지 알지 못합니다. 대신 런타임에서, 러스트는
트레잇 객체 내에 존재하는 포인터를 사용하여 어떤 메소드가 호출될지 알아냅니다.
정적 디스패치 시에는 일어나지 않는 이러한 탐색이 발생할 때 런타임 비용이 있습니다.
동적 디스패치는 또한 컴파일러가 메소드의 코드를 인라인 (inline) 화하는 선택을
막아버리는데, 이것이 결과적으로 몇가지 최적화를 수행하지 못하게 합니다. 하지만,
우리는 추가적인 유연성을 얻어 Listing 17-5와 같은 코드를 작성할 수 있었고,
Listing 17-9과 같은 지원이 가능해졌으니, 여기에는 고려할 기회비용이 있다고
하겠습니다.</p>
<h3 id="트레잇-객체에-대하여-객체-안전성이-요구됩니다"><a class="header" href="#트레잇-객체에-대하여-객체-안전성이-요구됩니다">트레잇 객체에 대하여 객체 안전성이 요구됩니다</a></h3>
<p>여러분은 <em>객체-안전 (object-safe)</em> 한 트레잇만 트레잇 객체로 만들 수 있습니다.
트레잇 객체를 안전하게 만드는 모든 속성들을 관장하는 몇가지 복잡한 규칙이 있지만,
실전에서는 두 가지 규칙만 관련되어 있습니다. 어떤 트레잇 내의 모든 메소드들이 다음과
같은 속성들을 가지고 있다면 해당 트레잇은 객체 안전합니다:</p>
<ul>
<li>반환값의 타입이 <code>Self</code>가 아닙니다.</li>
<li>제네릭 타입 매개변수가 없습니다.</li>
</ul>
<p><code>Self</code> 키워드는 우리가 트레잇 혹은 메소드를 구현하고 있는 타입의
별칭입니다. 트레잇 객체가 반드시 객체 안전해야 하는 이유는 일단
여러분이 트레잇 객체를 사용하면, 러스트가 트레잇에 구현된 구체(concrete)
타입을 알 수 없기 때문입니다. 만약 트레잇 메소드가 고정된 <code>Self</code>
타입을 반환하는데 트레잇 객체는 <code>Self</code>의 정확한 타입을 잊었다면,
메소드가 원래 구체 타입을 사용할 수 있는 방법이 없습니다. 트레잇을
사용할 때 구체 타입 파라미터로 채워지는 제네릭 타입 파라미터도
마찬가지입니다: 그 구체 타입들은 해당 트레잇을 구현하는 타입의 일부가
됩니다. 트레잇 객체를 사용을 통해 해당 타입을 잊게되면, 제네릭 타입
파라미터를 채울 타입을 알 수 없습니다. </p>
<p>메소드가 객채 안전하지 않은 트레잇의 예는 표준 라이브러리의 <code>Clone</code>
트레잇입니다. <code>Clone</code> 트레잇의 <code>clone</code> 메소드에 대한 시그니처는
다음과 같습니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Clone {
    fn clone(&amp;self) -&gt; Self;
}
<span class="boring">}</span></code></pre></pre>
<p><code>String</code> 타입은 <code>Clone</code> 트레잇을 구현하고, <code>String</code> 인스턴스에 대하여
<code>clone</code> 메소드를 호출하면 우리는 <code>String</code>의 인스턴스를 반환받을 수 있습니다.
비슷하게, 우리가 <code>Vec&lt;T&gt;</code>의 인스턴스 상의 <code>clone</code>을 호출하면, 우리는 <code>Vec&lt;T&gt;</code>
인스턴스를 얻을 수 있습니다. <code>clone</code> 선언은 <code>Self</code>에 어떤 타입이 사용되는지 알
필요가 있는데, 왜냐면 그게 반환 타입이기 때문이죠. </p>
<p>컴파일러는 여러분이 트레잇 객체와 관련하여 객체 안전성 규칙을 위반하는
무언가를 시도하려고 하면 알려줍니다. 예를 들어, Listing 17-4에서
<code>Screen</code> 구조체가 <code>Draw</code> 트레잇 대신 <code>Clone</code> 트레잇을 구현하는
타입을 보관하도록 아래처럼 구현 시도를 해봅시다:</p>
<pre><code class="language-rust ignore">pub struct Screen {
    pub components: Vec&lt;Box&lt;Clone&gt;&gt;,
}</code></pre>
<p>우리는 이런 에러를 얻게 될 겁니다:</p>
<pre><code class="language-text">error[E0038]: the trait `std::clone::Clone` cannot be made into an object
 --&gt; src/lib.rs:2:5
  |
2 |     pub components: Vec&lt;Box&lt;Clone&gt;&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::clone::Clone` cannot be
made into an object
  |
  = note: the trait cannot require that `Self : Sized`
</code></pre>
<p>이 에러가 의미하는 바는 이러한 방식으로 이 트레잇을 트레잇 객체로사 사용할 수 없다는 겁니다.
혹시 객체 안전에 대해 보다 자세하게 알고 싶으시면 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md">Rust RFC 255</a>를 참고하세요.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch17-01-what-is-oo.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch17-03-oo-design-patterns.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch17-01-what-is-oo.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch17-03-oo-design-patterns.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
