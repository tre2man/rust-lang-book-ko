<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>고급 라이프타임 - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="foreword.html">들어가기에 앞서</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">소개</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> 시작하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> 설치하기</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> 추리 게임 튜토리얼</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> 보편적인 프로그래밍 개념</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> 변수와 가변성</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> 데이터 타입들</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> 함수 동작 원리</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> 주석</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> 제어문</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> 소유권 이해하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> 소유권이 뭔가요?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> 참조자와 빌림</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> 슬라이스</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 연관된 데이터들을 구조체로 다루기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> 구조체를 정의하고 생성하기</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> 구조체를 이용한 예제 프로그램</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> 메소드 문법</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> 열거형과 패턴 매칭</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> 열거형 정의하기</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match 흐름 제어 연산자</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if let을 사용한 간결한 흐름 제어</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> 모듈</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod와 파일 시스템</a></li><li class="chapter-item expanded "><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> pub으로 가시성 제어하기</a></li><li class="chapter-item expanded "><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> use로 이름 가져오기</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> 일반적인 컬렉션</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> 벡터</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> 스트링</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> 해쉬맵</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> 에러 처리</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic!과 함께하는 복구 불가능한 에러</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result와 함께하는 복구 가능한 에러</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!이냐, panic!이 아니냐, 그것이 문제로다</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> 제네릭 타입, 트레잇, 그리고 라이프타임</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> 제네릭 데이터 타입</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> 트레잇: 공유 동작을 정의하기</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> 라이프타임을 이용한 참조자 유효화</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> 테스팅</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> 테스트 작성하기</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> 테스트 실행하기</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> 테스트 조직화</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> I/O 프로젝트: 커맨드 라인 프로그램 만들기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> 커맨드 라인 인자 허용하기</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> 파일 읽기</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> 모듈성과 에러처리의 향상을 위한 리팩토링</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> 테스트 주도 개발로 라이브러리의 기능 개발하기</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> 환경 변수들을 활용하기</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> 표준출력 대신 표준에러로 에러메시지 출력하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> 함수형 언어의 특성들: 반복자들과 클로저들</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> 클로저: 환경을 캡쳐할 수 있는 익명 함수</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> 반복자로 일련의 항목들 처리하기</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> I/O 프로젝트 개선하기</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> 성능 비교하기: 루프 vs. 반복자</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Cargo와 Crates.io 더 알아보기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> 릴리즈 프로필을 이용해 빌드 커스터마이징하기</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Crates.io에 크레이트 배포하기</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo 작업공간</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> cargo install을 이용해 Crates.io에서 바이너리 설치하기</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> 커스텀 명령어로 Cargo 확장하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> 스마트 포인터</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box&lt;T&gt;는 힙에 있는 데이터를 가리키고 알려진 크기를 갖습니다</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Deref 트레잇은 참조자를 통하여 데이터로의 접근을 허용합니다</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Drop 트레잇은 메모리 정리 코드를 실행시킵니다</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, 참조 카운팅 스마트 포인터</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt;와 내부 가변성 패턴</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> 순환 참조를 만드는 것과 메모리 누수는 안전한 것에 해당됩니다</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> 겁없는 동시성</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> 스레드</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> 메세지 패싱</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> 공유 상태</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> 확장 가능한 동시성: Sync와 Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> 러스트의 객체 지향 프로그래밍 기능들</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> 객체 지향 언어의 특성</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> 트레잇 객체를 사용하여 다른 타입 간의 값 허용하기</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> 객체 지향 디자인 패턴 구현하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> 값의 구조와 매칭되는 패턴</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> 패턴이 사용될 수 있는 모든 곳</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> 반증 가능성: 패턴의 매칭이 실패할 수도 있는 경우</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> 패턴 문법의 모든 것</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> 고급 기능들</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> 안전하지 않은 러스트</a></li><li class="chapter-item expanded "><a href="ch19-02-advanced-lifetimes.html" class="active"><strong aria-hidden="true">19.2.</strong> 고급 라이프타임</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.3.</strong> 고급 트레잇</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.4.</strong> 고급 타입</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.5.</strong> 고급 함수와 클로저</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> 마지막 프로젝트: 멀티스레드 웹서버 만들기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> 싱글 스레드 웹서버</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> 싱글 스레드 서버를 멀티스레드 서버로 바꾸기</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 우아한 종료와 정리</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - 키워드</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - 연산자 및 기호</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - derive 가능한 트레잇</a></li><li class="chapter-item expanded "><a href="appendix-04-macros.html"><strong aria-hidden="true">21.4.</strong> D - 매크로</a></li><li class="chapter-item expanded "><a href="appendix-05-translation.html"><strong aria-hidden="true">21.5.</strong> E - 본 책의 번역본 목록</a></li><li class="chapter-item expanded "><a href="appendix-06-newest-features.html"><strong aria-hidden="true">21.6.</strong> F - 새로운 기능</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - 러스트가 만들어지는 과정과 “Nightly Rust”</a></li><li class="chapter-item expanded "><a href="appendix-08-glossary.html"><strong aria-hidden="true">21.8.</strong> H - 번역 용어 정리</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="고급-라이프타임"><a class="header" href="#고급-라이프타임">고급 라이프타임</a></h2>
<p>10장의 “라이프타임을 이용한 참조자 유효화”절에서, 여러분은 러스트에게 서로 다른
참조자의 라이프타임이 어떻게 연관되는지를 알려주기 위하여 참조자에 대한 라이프타임
파라미터의 명시 방법을 배웠습니다. 여러분은 모든 참조자가 라이프타임을 갖지만,
거의 대부분의 경우 러스트가 어떻게 이 라이프타임을 생략시켜주는지도 봤습니다.
이제 우리는 아직 다루지 못했던 라이프타임의 세가지 고급 기능을 살펴볼 것입니다:</p>
<ul>
<li>라이프타임 서브타이핑 (subtyping): 한 라이프타임이 다른 라이프타임보다 오래 사는 것을 보장하기</li>
<li>라이프타임 바운드: 제네릭 타입을 가리키는 참조자를 위한 라이프타임 명시하기</li>
<li>트레잇 객체 라이프타임의 추론: 컴파일러는 어떻게 트레잇 객체의 라이프타임을 추론하며
언제 이들을 명시할 필요가 있는지에 대하여</li>
</ul>
<h3 id="라이프타임-서브타이핑은-하나의-라이프타임이-다른-것보다-오래-사는-것을-보장합니다"><a class="header" href="#라이프타임-서브타이핑은-하나의-라이프타임이-다른-것보다-오래-사는-것을-보장합니다">라이프타임 서브타이핑은 하나의 라이프타임이 다른 것보다 오래 사는 것을 보장합니다</a></h3>
<p><em>라이프타임 서브타이핑</em>은 하나의 라이프타임이 다른 라이프타임보다 오래 살아야 함을
명시합니다. 라이프타임 서브타이핑을 탐구하기 위해서, 우리가 파서를 작성하길 원한다고
상상해 보세요. 우리가 파싱하는 중인 스트링에 대한 참조자를 가지고 있는 <code>Context</code>라는
이름의 구조체를 사용하겠습니다. 이 스트링을 파싱하고 성공 혹은 실패를 반환하는 파서를
작성할 것입니다. 이 파서는 파싱을 하기 위해 <code>Context</code>를 빌릴 필요가 있을 것입니다.
Listing 19-12는 이 파서 코드를 구현한 것인데, 필요한 라이프타임 명시가 제외되어
있고, 따라서 컴파일되지 않습니다.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">struct Context(&amp;str);

struct Parser {
    context: &amp;Context,
}

impl Parser {
    fn parse(&amp;self) -&gt; Result&lt;(), &amp;str&gt; {
        Err(&amp;self.context.0[1..])
    }
}</code></pre>
<p><span class="caption">Listing 19-12: 라이프타임 명시 없이 파서를
정의하기</span></p>
<p>이 코드를 컴파일하면 에러를 내는데 그 이유는 러스트가 <code>Context</code>의 스트링 슬라이스와
<code>Parser</code> 내의 <code>Context</code>의 참조자에 대한 라이프타임 파라미터를 기대하기 때문입니다.</p>
<p>단순함을 위해서, 이 <code>parse</code> 함수는 <code>Result&lt;(), &amp;str&gt;</code>를 리턴합니다.
즉, 이 함수는 성공시에 아무것도 하지 않고, 실패시에는 파싱이 올바르기 되지
않은 스트링 슬라이스 부분을 반환할 것입니다. 실제 구현은 더 많은 에러 정보를
제공하고 파싱이 성공하면 구조화된 데이터 타입을 반환할 것입니다. 우리는
이러한 상세 부분은 다루지 않을 것인데, 이 예제의 라이프타임 부분과는
관련이 없기 때문입니다.</p>
<p>이 코드를 계속 단순하게 유지하기 위해, 우리는 어떠한 파싱 로직도 작성하지
않고 있습니다. 하지만, 유효하지 않은 입력을 처리하기 위하여 파싱 로직의
어딘가에서 잘못된 입력 부분을 참조하는 에러를 반환하기란 매우 가능성이 큽니다;
이 참조자가 코드 예제를 라이프타임에 대한 관점에서 흥미롭게 만들어주는 것입니다.
우리 파서의 로직이 첫번째 바이트 이후의 입력은 유효하지 않다고 판단했다고
가정해봅시다. 첫번째 바이트가 유효한 문자 범위 상에 있지 않으면 이 코드는
패닉을 일으킬 수도 있음을 주의하세요; 다시 한번, 우리는 수반되는 라이프타임에
집중하도록 예제를 단순화하는 중입니다.</p>
<p>이 코드를 컴파일하기 위해서는 <code>Context</code> 내의 스트링 슬라이스와 <code>Parser</code>
내의 <code>Conext</code>를 가리키는 참조자에 대한 라이프타임 파라미터를 채워줄
필요가 있습니다. 이를 위한 가장 직관적인 방법은 Listing 19-13에서
보시는 것과 같이 모든 곳에 동일한 라이프타임 이름을 사용하는 것입니다. 10장의
“구조체 정의 상에서의 라이프타임 명시”절에서 본 것처럼 각각의
<code>struct Context&lt;'a&gt;</code>, <code>struct Parser&lt;'a&gt;</code>와 <code>impl&lt;'a&gt;</code>는 새로운
라이프타임 파라미터를 선언중이라는 점을 상기하세요. 그 이름들이 모두 동일하게 등장한
반면, 예제에서 선언된 이 3개의 라이프타임 파라미터는 모두 연관되어 있지 않습니다.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Context&lt;'a&gt;(&amp;'a str);

struct Parser&lt;'a&gt; {
    context: &amp;'a Context&lt;'a&gt;,
}

impl&lt;'a&gt; Parser&lt;'a&gt; {
    fn parse(&amp;self) -&gt; Result&lt;(), &amp;str&gt; {
        Err(&amp;self.context.0[1..])
    }
}
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 19-13: <code>Context</code>와 <code>Parser</code>의 모든 참조자에 라이프타임
파라미터 명시하기</span></p>
<p>이 코드는 잘 컴파일됩니다. 이 코드는 러스트에게 <code>Parser</code>가 라이프타임이 <code>'a</code>인
<code>Context</code>를 가리키는 참조자를 가지고 있고, <code>Context</code>는 <code>Parser</code> 내의 <code>Context</code>
참조자만큼 오래 사는 스트링 슬라이스를 가지고 있다고 말해줍니다. 러스트의 컴파일러
에러 메세지는 이 참조자들에게 라이프타임 파라미터가 필요하다고 기술했었고, 우리가
방금 그 라이프타임 파라미터를 추가했습니다.</p>
<p>다음으로, Listing 19-14에서 우리는 <code>Context</code>의 인스턴스를 받아서,
이 콘텍스트를 파싱하기 위해 <code>Parser</code>를 사용하고, <code>parse</code>가 반환하는
것을 반환하는 함수를 추가할 것입니다. 아래 코드는 잘 동작하지 않습니다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
    Parser { context: &amp;context }.parse()
}</code></pre>
<p><span class="caption">Listing 19-14: <code>Context</code>를 받아서 <code>Parser</code>를 사용하는
<code>parser_context</code> 함수 추가 시도</span></p>
<p><code>parse_context</code> 함수를 추가하고 컴파일 시도를 하면 두 개의 장황한
에러를 얻게 됩니다:</p>
<pre><code class="language-text">error[E0597]: borrowed value does not live long enough
  --&gt; src/lib.rs:14:5
   |
14 |     Parser { context: &amp;context }.parse()
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ does not live long enough
15 | }
   | - temporary value only lives until here
   |
note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 13:1...
  --&gt; src/lib.rs:13:1
   |
13 | / fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
14 | |     Parser { context: &amp;context }.parse()
15 | | }
   | |_^

error[E0597]: `context` does not live long enough
  --&gt; src/lib.rs:14:24
   |
14 |     Parser { context: &amp;context }.parse()
   |                        ^^^^^^^ does not live long enough
15 | }
   | - borrowed value only lives until here
   |
note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 13:1...
  --&gt; src/lib.rs:13:1
   |
13 | / fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
14 | |     Parser { context: &amp;context }.parse()
15 | | }
   | |_^
</code></pre>
<p>이 에러들은 만들어진 <code>Parser</code> 인스턴스와 <code>context</code> 파라미터가 
<code>parse_context</code> 함수의 끝까지만 산다고 기술하고 있습니다.
그러나 이 둘 모두 함수의 전체 라이프타임보다 더 살아야 할 필요가 있습니다.</p>
<p>바꿔 말하면, <code>Parse</code>와 <code>context</code>는 전체 함수보다 오래 살아야 할 필요가
있고 이 코드의 모든 참조자들이 항상 유효하기 위해서 함수가 끝날 때는 물론
함수가 시작될 때도 유효해야 할 필요가 있습니다. 우리가 만든 <code>Parser</code>와
<code>context</code> 파라미터는 함수 끝에서 스코프 밖으로 벗어나는데, 그 이유는
<code>parse_context</code>가 <code>context</code>의 소유권을 갖기 때문입니다.</p>
<p>이 에러가 왜 발생하는지 알아내기 위해, Listing 19-13에 있는 정의 부분 중
특히 <code>parse</code> 메소드의 시그니처에 있는 참조자들을 다시 살펴봅시다:</p>
<pre><code class="language-rust ignore">    fn parse(&amp;self) -&gt; Result&lt;(), &amp;str&gt; {</code></pre>
<p>생략 규칙 기억하시죠? 만일 참조자의 라이프타임을 생략하지 않고 명시했다면,
시그니처는 다음과 같을 것입니다:</p>
<pre><code class="language-rust ignore">    fn parse&lt;'a&gt;(&amp;'a self) -&gt; Result&lt;(), &amp;'a str&gt; {</code></pre>
<p>즉, <code>parse</code>의 반환값의 에러 부분은 <code>Parser</code> 인스턴스의 라이프타임에
묶여 있는 라이프타임을 갖고 있다는 것입니다 (<code>parse</code> 메소드 시그니처 내의
<code>&amp;self</code>의 것이지요). 이는 타당합니다: 반환되는 스트링 슬라이스는
<code>Parser</code>가 가지고 있는 <code>Context</code> 인스턴스의 스트링 슬라이스를 참조하고,
<code>Parser</code> 구조체의 정의는 <code>Context</code>의 참조자의 라이프타임과 <code>Context</code>가
가지고 있는 스트링 슬라이스의 라이프타임이 동일해야 함을 기술하고
있습니다.</p>
<p>문제는 <code>parse_context</code> 함수가 <code>parse</code>로부터 값을 반환하고 있으므로,
<code>parse_context</code>의 반환값의 라이프타임 또한 <code>Parser</code>의 라이프타임과
묶여 있다는 것입니다. 그러나 <code>parse_context</code> 함수 내에서 만들어진 <code>Parser</code>
인스턴스는 함수 끝을 벗어나 살 수 없을 것이고 (일시적인 객체입니다), <code>context</code>는
함수의 끝에서 스코프 밖으로 벗어날 것입니다 (<code>parse_context</code>가 이것의
소유권을 가지고 있습니다).</p>
<p>러스트는 우리가 함수의 끝에서 스코프 밖으로 벗어나는 값의 참조자를 반환 시도를
하는 중이라고 생각하는데, 이는 우리가 모든 라이프타임을 동일한 라이프타임
파라미터로 명시했기 때문입니다. 이 어노테이션은 러스트에게 <code>Context</code>가
가지고 있는 스트링 슬라이스의 라이프타임은 <code>Parser</code>가 들고 있는 <code>Context</code>를
가리키는 참조자의 라이프타임의 것과 동일하다고 말하고 있습니다.</p>
<p><code>parse_context</code> 함수는 <code>parse</code> 함수의 내부에서 반환되는 스트링 슬라이스가
<code>Context</code>와 <code>Parser</code>보다 오래살 것이라는 것, 그리고 <code>parse_context</code>가
반환하는 참조자가 <code>Context</code> 혹은 <code>Parser</code>가 아닌 스트링 슬라이스를 참조하고
있다는 것을 알 수 없습니다.</p>
<p><code>parse</code>의 구현체가 무엇을 하는지 아는 것으로써, 우리는 <code>parse</code>의 반환값이
<code>Parser</code>에 묶여있는 유일한 이유가 이것이 스트링 슬라이스를 참조하고 있는
<code>Parser</code>의 <code>Context</code>를 참조하고 있기 때문이라는 것을 알게 되었습니다.
따라서, <code>parse_context</code>가 다루고자 하는 것은 실은 스트링 슬라이스의
라이프타임인 것입니다. 우리는 <code>Context</code> 내의 스트링 슬라이스와
<code>Parser</code> 내의 <code>Context</code>를 가리키는 참조자가 다른 라이프타임을 가지고 있고
<code>parse_context</code>의 반환값은 <code>Context</code>의 스트링 슬라이스의 라이프타임에
묶여있음을 알려줄 방법이 필요합니다.</p>
<p>먼저 Listing 19-15에서 보시는 것처럼 <code>Parser</code>와 <code>Context</code>에게 서로 다른
라이프타임 파라미터를 주는 시도를 하겠습니다. 우리는 <code>'s</code>와 <code>'c</code>라는 라이프타임 파라미터
이름을 사용하여 어떤 라이프타임이 <code>Context</code> 내의 스트링 슬라이스에 포함되고 어떤 라이프타임이
<code>Parser</code> 내의 <code>Context</code>를 가리키는 참조자에 초함되는지 명확히 할 것입니다. 이 해결책이
문제를 완전히 해결하지는 않겠지만, 이것이 시작점이라는 점을 주목하세요. 이 소스 코드
수정이 왜 컴파일 시도에 충분치 않은지 살펴보겠습니다.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">struct Context&lt;'s&gt;(&amp;'s str);

struct Parser&lt;'c, 's&gt; {
    context: &amp;'c Context&lt;'s&gt;,
}

impl&lt;'c, 's&gt; Parser&lt;'c, 's&gt; {
    fn parse(&amp;self) -&gt; Result&lt;(), &amp;'s str&gt; {
        Err(&amp;self.context.0[1..])
    }
}

fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
    Parser { context: &amp;context }.parse()
}</code></pre>
<p><span class="caption">Listing 19-15: 스트링 슬라이스에 대한 참조자와 <code>Context</code>에
대한 참조자에 대해 서로 다른 라이프타임 파라미터 지정하기</span></p>
<p>우리가 Listing 19-13에서 명시했던 것과 모두 동일한 위치에 있는 참조자의
라이프타임을 명시했습니다. 하지만 이번에는 참조자가 스트링 슬라이스에 포함되는지
혹은 <code>Context</code>에 포함되는지 여부에 따라 다른 파라미터를 사용했습니다. 우리는
또한 <code>parse</code>의 반환값의 스트링 슬라이스 부분에도 이것이 <code>Context</code> 내의
스트링 슬라이스의 라이프타임에 포함된다는 것을 나타내기 위해서 어노테이션을
추가했습니다.</p>
<p>이제 컴파일 시도를 하면, 다음과 같은 에러를 얻습니다:</p>
<pre><code class="language-text">error[E0491]: in type `&amp;'c Context&lt;'s&gt;`, reference has a longer lifetime than the data it references
 --&gt; src/lib.rs:4:5
  |
4 |     context: &amp;'c Context&lt;'s&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^
  |
note: the pointer is valid for the lifetime 'c as defined on the struct at 3:1
 --&gt; src/lib.rs:3:1
  |
3 | / struct Parser&lt;'c, 's&gt; {
4 | |     context: &amp;'c Context&lt;'s&gt;,
5 | | }
  | |_^
note: but the referenced data is only valid for the lifetime 's as defined on the struct at 3:1
 --&gt; src/lib.rs:3:1
  |
3 | / struct Parser&lt;'c, 's&gt; {
4 | |     context: &amp;'c Context&lt;'s&gt;,
5 | | }
  | |_^
</code></pre>
<p>러스트는 <code>'c</code>와 <code>'s</code> 사이에 어떠한 관계도 알지 못합니다. 이를 유효화하기 위해,
<code>'s</code> 라이프타임을 가진 <code>Context</code> 내의 참조자 데이터는 <code>'c</code> 라이프타임을 가진
참조자보다 더 오래 산다는 것을 보장하기 위해 제한될 필요가 있습니다. 만일 <code>'s</code>가
<code>'c</code>보다 오래 살지 못한다면, <code>Context</code>의 참조자가 유효하지 않을 수도 있습니다.</p>
<p>이제 우리는 이 절의 요점을 얻었습니다: 러스트의 기능인 <em>라이프타임 서브타이핑</em>은
하나의 라이프타임 파라미터가 최소한 다른 것만큼 오래 산다는 것을 명시힙니다.
우리가 라이프타임 파라미터를 선언하는 꺽쇠 괄호 내에서, 우리는 라이프타임 <code>'a</code>을
평소처럼 선언하고, 문법 <code>'b: 'a</code>를 사용하여 <code>'b</code>를 선언함으로써 라이프타임 <code>'b</code>가
최소 <code>'a</code> 만큼 오래 산다고 선언할 수 있습니다.</p>
<p>우리의 <code>Parser</code> 정의부에서, <code>'s</code> (스트링 슬라이스의 라이프타임) 가 최소한 <code>'c</code>
(<code>Context</code>를 가리키는 참조자의 라이프타임) 만큼 오래 사는 것이 보장됨을 말하기
위해서, 아래와 같이 라이프타임 선언을 변경합니다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Context&lt;'a&gt;(&amp;'a str);
</span><span class="boring">
</span>struct Parser&lt;'c, 's: 'c&gt; {
    context: &amp;'c Context&lt;'s&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>이제 <code>Parser</code> 내에 있는 <code>Context</code>에 대한 참조자와 <code>Context</code> 내의 스트링 슬라이스를
가리키는 참조자는 다른 라이프타임을 갖습니다; 우리는 스트링 슬라이스의 라이프타임이
<code>Context</code>를 가리키는 참조자보다 더 오래 살 것이란 보장을 했습니다.</p>
<p>참 길고 지루한 예제였습니다만, 이 장의 첫 부분에서도 언급했듯,
러스트의 고급 기능들은 매우 구체적입니다. 우리가 이 예제에서 묘사한
문법이 자주 필요치는 않겠지만, 특정한 상황에서 여러분이 참조해야 하는
무언가를 참조하는 방법을 알아둬야 할 것입니다.</p>
<h3 id="제네릭-타입에-대한-참조자-상의-라이프타임-바운드"><a class="header" href="#제네릭-타입에-대한-참조자-상의-라이프타임-바운드">제네릭 타입에 대한 참조자 상의 라이프타임 바운드</a></h3>
<p>10장의 “트레잇 바운드”절에서, 우리는 제네릭 타입 상의 트레잇 바운드를 사용하는 것에 대해
논했습니다. 우리는 또한 제네릭 타입의 제약사항으로서 라이프타임 파라미터를 추가할 수 있습니다;
이를 <em>라이프타임 바운드 (lifetime bound)</em> 라고 부릅니다. 라이프타임 바운드는 제네릭 타입
내의 참조자들이 참조하고 있는 데이터보다 오래 살지 못하도록 러스트가 확인하는 것을 돕습니다.</p>
<p>한 가지 예로, 참조자에 대한 래퍼 (wrapper) 인 타입을 고려해보세요. 15장의
“<code>RefCell&lt;T&gt;</code>와 내부 가변성 패턴”절에서 나온 <code>RefCell&lt;T&gt;</code> 타입을
상기해보세요: 이것의 <code>borrow</code> 및 <code>borrow_mut</code> 메소드는 각각 <code>Ref</code> 및
<code>RefMut</code> 타입을 반환합니다. 이 타입들은 런타임에 빌림 규칙을 계속 따르게
하는 참조자들의 레퍼입니다. <code>Ref</code> 구조체의 정의는 Listing 19-16과 같은데,
지금은 라이프타임 바운드 없이 쓰였습니다:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">struct Ref&lt;'a, T&gt;(&amp;'a T);</code></pre>
<p><span class="caption">Listing 19-16: 시작을 위해 라이프타임 바운드 없이 쓰는
제네릭 타입에 대한 참조자를 감싼 구조체 정의하기</span></p>
<p>제네릭 타입 <code>T</code>과의 관계에 대한 라이프타임 <code>'a</code>의 명시적 제약이 없으면,
러스트는 에러를 내게 되는데 그 이유는 제네릭 타입 <code>T</code>가 얼마나 오래 살
것인지를 모르기 때문입니다:</p>
<pre><code class="language-text">error[E0309]: the parameter type `T` may not live long enough
 --&gt; src/lib.rs:1:19
  |
1 | struct Ref&lt;'a, T&gt;(&amp;'a T);
  |                   ^^^^^^
  |
  = help: consider adding an explicit lifetime bound `T: 'a`...
note: ...so that the reference type `&amp;'a T` does not outlive the data it points at
 --&gt; src/lib.rs:1:19
  |
1 | struct Ref&lt;'a, T&gt;(&amp;'a T);
  |                   ^^^^^^
</code></pre>
<p><code>T</code>가 어떠한 타입도 될 수 있으므로, <code>T</code>는 참조자 혹은 하나 이상의 참조자를 가지고 있는
타입이 될 수 있는데, 각각은 자신의 라이프타임을 가질 수 있습니다. 러스트는 <code>T</code>가
<code>'a</code>만큼 오래 살 수 있는지 확신할 수 없습니다.</p>
<p>다행히도, 위의 경우 에러가 라이프타임 바운드를 어떻게 명시하는지에 대한 도움되는
조언을 제공합니다:</p>
<pre><code class="language-text">consider adding an explicit lifetime bound `T: 'a` so that the reference type
`&amp;'a T` does not outlive the data it points at
</code></pre>
<p>Listing 19-17은 우리가 제네릭 타입 <code>T</code>를 선언할 때 라이프타임 바운드를 명시함으로서
이 조언을 어떻게 적용하는지를 보여줍니다:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ref&lt;'a, T: 'a&gt;(&amp;'a T);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 19-17: <code>T</code> 상의 라이프타임 바운드를 추가하여
<code>T</code> 내의 어떠한 참조자들도 최소한 <code>'a</code>만큼 오래 살 것임을 명시하기</span></p>
<p>이 코드는 이제 컴파일되는데, <code>T: 'a</code> 문법을 사용하면 <code>T</code>가 어떤 타입이든 될 수 있지만,
만일 어떠한 참조자라도 포함하고 있다면, 그 참조자들은 최소한 <code>'a</code>만큼은 오래 살아야 함을
명시하고 있기 때문입니다.</p>
<p>Listing 19-18의 <code>StaticRef</code> 구조체 정의 부분에서 <code>T</code>에 <code>'static</code>
라이프타임 바운드를 추가한 것처럼, 우리는 이 문제를 다른 방식으로 해결할 수도
있습니다. 이는 만일 <code>T</code>가 어떠한 참조자를 가지고 있다면, 이들은 반드시 <code>'static</code>
라이프타임을 가져야 함을 의미합니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct StaticRef&lt;T: 'static&gt;(&amp;'static T);
<span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 19-18: <code>'static</code> 라이프타임 바운드를
<code>T</code>에 추가하여 <code>T</code>가 오직 <code>'static</code> 참조자만을 갖거나 아무런 참조자도 없도록
제한하기</span></p>
<p><code>'static</code>이 전체 프로그램만큼 오래 살아야 함을 뜻하기 때문에, 아무런
참조자도 없는 타입도 모든 참조자들이 전체 프로그램 만큼 오래 사는 규정을
만족합니다 (왜냐면 아무런 참조자도 없으니까요). 참조자가 충분히 오래 사는지에
대해 염려하는 빌림 검사기를 위하여, 아무런 참조자도 없는 타입과 영원히
사는 참조자들을 가진 타입 간의 실질적 구분은 없습니다: 둘다 그것이 참조하고
있는 것보다 더 짧은 라이프타임을 가진 참조자인지 아닌지를 결정하는 관점에서는
같습니다.</p>
<h3 id="트레잇-객체-라이프타임의-추론"><a class="header" href="#트레잇-객체-라이프타임의-추론">트레잇 객체 라이프타임의 추론</a></h3>
<p>17장의 “서로 다른 타입의 값을 허용하는 트레잇 객체를 사용하기”절에서,
우리는 동적 디스패치를 이용할 수 있게 해주는 참조자 뒤의 트레잇으로 구성된
트레잇 객체를 논했습니다. 우리는 아직 트레잇 객체 내의 트레잇을 구현한
타입이 자신만의 라이프타임을 가지면 어떤일이 벌어지는지 논하지는 않았습니다.
트레잇 <code>Red</code>와 구조체 <code>Ball</code>를 가지고 있는 Listing 19-19을 고려해보세요.
<code>Ball</code> 구조체는 참조자를 가지고 있고 (따라서 라이프타임 파라미터를 가지고 있죠)
또한 트레잇 <code>Red</code>를 구현합니다. 우리는 <code>Ball</code>의 인스턴스를 트레잇 객체
<code>Box&lt;Red&gt;</code>로서 사용하기를 원합니다:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">trait Red { }

struct Ball&lt;'a&gt; {
    diameter: &amp;'a i32,
}

impl&lt;'a&gt; Red for Ball&lt;'a&gt; { }

fn main() {
    let num = 5;

    let obj = Box::new(Ball { diameter: &amp;num }) as Box&lt;Red&gt;;
}</code></pre></pre>
<p><span class="caption">Listing 19-19: 트레잇 객체와 함께 라이프타임 파라미터를
갖는 타입 사용하기</span></p>
<p>비록 우리가 아직 <code>obj</code>과 관련된 라이프타임을 명시적으로 적지 않았으나,
이 코드는 에러 없이 컴파일됩니다. 이 코드는 동작하는데 그 이유는
라이프타임과 트레잇 객체가 함께 동작하는 규칙이 있기 때문입니다:</p>
<ul>
<li>트레잇 객체의 기본 라이프타임은 <code>'static</code> 입니다.</li>
<li><code>&amp;'a Trait</code> 혹은 <code>&amp;'a mut Trait</code>을 쓴 경우, 트레잇 객체의 기본
라이프타임은 <code>'a</code> 입니다.</li>
<li>단일 <code>T: 'a</code> 구절을 쓴 경우, 트레잇 객체의 기본 라이프타임은 <code>'a</code>
입니다.</li>
<li>여러 개의 <code>T: 'a</code> 같은 구절들을 쓴 경우, 기본 라이프타임는 없습니다;
우리가 명시적으로 써야합니다.</li>
</ul>
<p>우리가 명시적으로 써야 할 때, <code>Box&lt;Red&gt;</code> 같은 트레잇 객체에 대해 <code>Box&lt;Red + 'static&gt;</code>
혹은 <code>Box&lt;Red + 'a&gt;</code> 같은 문법을 써서 라이프타임 바운드를 추가할 수 있는데,
이는 참조자가 전체 프로그램 동안 사는지 혹은 그렇지 않은지에 따라 달려 있습니다.
다른 바운드를 사용할 때처럼, 라이프타임 바운드를 추가하는 문법은 타입 내에 참조자를
가진 어떠한 <code>Red</code> 트레잇의 구현체라도 그 타입의 참조자처럼 트레잇 객체 내에
명시된 동일한 라이프타임을 가져야 한다는 뜻입니다.</p>
<p>다음으로, 트레잇을 관리하는 다른 고급 기능을 살펴봅시다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch19-01-unsafe-rust.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch19-03-advanced-traits.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch19-01-unsafe-rust.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch19-03-advanced-traits.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
